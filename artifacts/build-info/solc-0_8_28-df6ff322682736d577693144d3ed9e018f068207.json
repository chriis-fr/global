{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-df6ff322682736d577693144d3ed9e018f068207",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "src/app/contracts/InvoiceManager.sol": "project/src/app/contracts/InvoiceManager.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/src/app/contracts/InvoiceManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\ninterface IERC20 {\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract InvoiceManager {\r\n    // Contract is fully implemented - not abstract\r\n    struct Invoice {\r\n        address issuer;\r\n        address payer;\r\n        address token; // address(0) for CELO\r\n        uint256 amount;\r\n        bool paid;\r\n    }\r\n\r\n    uint256 public feePercentage; // in basis points (10000 = 100%)\r\n    uint256 public feeThreshold;  // minimum amount to apply fee\r\n    address public feeRecipient;\r\n\r\n    mapping(string => Invoice) public invoices;\r\n\r\n    event InvoiceCreated(string invoiceId, address issuer, address payer, address token, uint256 amount);\r\n    event InvoicePaid(string invoiceId, address payer, uint256 fee);\r\n\r\n    constructor(uint256 _feePercentage, uint256 _feeThreshold, address _feeRecipient) {\r\n        feePercentage = _feePercentage;\r\n        feeThreshold = _feeThreshold;\r\n        feeRecipient = _feeRecipient;\r\n    }\r\n\r\n    function createInvoice(\r\n        string memory invoiceId,\r\n        address payer,\r\n        address token,\r\n        uint256 amount\r\n    ) external {\r\n        require(invoices[invoiceId].issuer == address(0), \"Invoice exists\");\r\n\r\n        invoices[invoiceId] = Invoice({\r\n            issuer: msg.sender,\r\n            payer: payer,\r\n            token: token,\r\n            amount: amount,\r\n            paid: false\r\n        });\r\n\r\n        emit InvoiceCreated(invoiceId, msg.sender, payer, token, amount);\r\n    }\r\n\r\n    function payInvoice(string memory invoiceId) external payable {\r\n        Invoice storage inv = invoices[invoiceId];\r\n        require(!inv.paid, \"Invoice already paid\");\r\n        require(msg.sender == inv.payer, \"Not the payer\");\r\n\r\n        uint256 fee = 0;\r\n        if (inv.amount >= feeThreshold) {\r\n            fee = (inv.amount * feePercentage) / 10000;\r\n        }\r\n        uint256 paymentAmount = inv.amount - fee;\r\n\r\n        if (inv.token == address(0)) {\r\n            // CELO payment\r\n            require(msg.value >= inv.amount, \"Insufficient CELO\");\r\n            if (fee > 0) payable(feeRecipient).transfer(fee);\r\n            payable(inv.issuer).transfer(paymentAmount);\r\n        } else {\r\n            // ERC20 payment\r\n            require(IERC20(inv.token).transferFrom(msg.sender, inv.issuer, paymentAmount), \"ERC20 transfer failed\");\r\n            if (fee > 0) require(IERC20(inv.token).transferFrom(msg.sender, feeRecipient, fee), \"ERC20 fee failed\");\r\n        }\r\n\r\n        inv.paid = true;\r\n        emit InvoicePaid(invoiceId, msg.sender, fee);\r\n    }\r\n\r\n    // Admin functions\r\n    function updateFee(uint256 _feePercentage, uint256 _feeThreshold, address _feeRecipient) external {\r\n        require(msg.sender == feeRecipient, \"Only feeRecipient can update\");\r\n        feePercentage = _feePercentage;\r\n        feeThreshold = _feeThreshold;\r\n        feeRecipient = _feeRecipient;\r\n    }\r\n}\r\n"
      }
    }
  }
}